<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>software design on dzaka.ammar</title>
    <link>http://example.org/tags/software-design/</link>
    <description>Recent content in software design on dzaka.ammar</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 16 Aug 2021 01:06:07 +0700</lastBuildDate><atom:link href="http://example.org/tags/software-design/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Factory Pattern</title>
      <link>http://example.org/posts/202108131944_factory_pattern/</link>
      <pubDate>Mon, 16 Aug 2021 01:06:07 +0700</pubDate>
      
      <guid>http://example.org/posts/202108131944_factory_pattern/</guid>
      <description>Factory method menyediakan cara untuk membuat sebuat object pada superclass, namun memberikan cara subclass untuk merubah type nya.
Karakteristik  Ada abstraksi dari produk object menggunakan interface Setiap concrete implementation object produk tersebut, harus men=satisfy interface Ada sebuah function yang menjadi logic creational nya Function tersebut membutuhkan &amp;ldquo;data&amp;rdquo;, untuk menentukan object mana yang harus di create  package main // Coffee adalah abstraksi dari product type Coffee interface { Make() } // Arabica adalah konkrit product type Arabica struct {} func(a Arabica) Make() {} // Robusta adalah konkrit product type Robusta struct {} func(r Robusta) Make() {} // Data yang dibutuhkan untuk menentukan tipe produk const ( Arabica = iota Robusta ) // GetCoffee adalah fungsi creational dari produk Coffee func GetCoffee(t int) Coffee { switch t { case Arabica: return Arabica{} default: return Robusta{} } } func main() { coffee := GetCoffee(Arabica) coffee.</description>
    </item>
    
  </channel>
</rss>
