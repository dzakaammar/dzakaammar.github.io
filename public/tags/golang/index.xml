<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on dzaka.ammar</title>
    <link>http://example.org/tags/golang/</link>
    <description>Recent content in golang on dzaka.ammar</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 16 Aug 2021 01:49:09 +0700</lastBuildDate><atom:link href="http://example.org/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Abstract Factory Pattern</title>
      <link>http://example.org/posts/202108141018_abstract_factory_pattern/</link>
      <pubDate>Mon, 16 Aug 2021 01:49:09 +0700</pubDate>
      
      <guid>http://example.org/posts/202108141018_abstract_factory_pattern/</guid>
      <description>Abstract factory menyediakan produksi families dari objek-objek yang terkait tanpa harus menentukan konkrit class nya
Karakteristik  Ada banyak tipe produk dan banyak variant dari produk. Contoh tipe produk: meja, kursi, sofa. Contoh variant dari produk: style modern, style kuno, style minimalis Famili produk (tipe produk + jenis variant nya) Tujuannya ingin membuat sebuah factory untuk memproduksi famili dari produk Adanya abstraksi dari masing-masing tipe object (abstract product). Contoh: interface meja, kursi, dan sofa Adanya abstraksi yang men-define struktur dari sebuah famili produk (abstract factory) Adanya sebuah fungsi/method yang menentukan factory mana yang digunakan berdasarkan data yang diberikan  package main const ( Breakfast = iota Lunch ) // Coffee adalah abstract product type Coffee interface { Drink() } // Bread adalah abstract product type Bread interface { Eat() } // Menu adalah abstract factory type Menu interface{ GetCoffee() Coffee GetBread() Bread } // GetMenu adalah fungsi untuk menentukan factory mana yang digunakan // berdasarkan data yang diberikan.</description>
    </item>
    
    <item>
      <title>Adapter Pattern</title>
      <link>http://example.org/posts/202108151843_adapter_pattern/</link>
      <pubDate>Mon, 16 Aug 2021 01:49:09 +0700</pubDate>
      
      <guid>http://example.org/posts/202108151843_adapter_pattern/</guid>
      <description>Bayangkan sebuah adapter dalam perangkat eletronik yang berfungsi menyambungkan antara hardware dengan sumber listrik. Analogi yang sama dengan Adapter Pattern .
 Adapter pattern adalah pattern untuk menghubungkan sebuah interface yang tidak compatible dengan existing interface, dengan membuat sebuah interface sebagai &amp;ldquo;adapter&amp;rdquo;. Yang tujuannya agar interface tersebut menjadi compatible. Secara sederhana, pattern ini digunakan untuk membuat object-object yang incompatible secara interface untuk saling berkolaborasi.
Adapter membungkus (wraps) sebuah object untuk menyembunyikan logic dan kompleksitas conversion, sehingga menjadikan object tersebut menjadi compatible</description>
    </item>
    
    <item>
      <title>Builder Pattern</title>
      <link>http://example.org/posts/202108151030_builder_pattern/</link>
      <pubDate>Mon, 16 Aug 2021 01:49:09 +0700</pubDate>
      
      <guid>http://example.org/posts/202108151030_builder_pattern/</guid>
      <description>Builder pattern menyediakan cara untuk meng-construct sebuah object yang kompleks step by step dan memproduksi berbagai macam type atau representasi object dengan satu cara konstruksi yang sama.
Bayangkan sebuah object memiliki beberapa parameter pada saat konstruksi. Parameter-parameter tersebut akan menentukan bagaimana sebuah object akan terbentuk. Parameter akan terus bertambah seiring banyaknya posibilitas konstruksi.
Kita dapat memilih untuk membuat sebuah atau beberapa fungsi untuk menghandle possibility tersebut:
package main type User struct { FirstName string LastName string Email string } func NewUserWithoutEmail(fn *string, ln *string) *User { u := &amp;amp;User{} if fn !</description>
    </item>
    
    <item>
      <title>Factory Pattern</title>
      <link>http://example.org/posts/202108131944_factory_pattern/</link>
      <pubDate>Mon, 16 Aug 2021 01:49:09 +0700</pubDate>
      
      <guid>http://example.org/posts/202108131944_factory_pattern/</guid>
      <description>Factory method menyediakan cara untuk membuat sebuat object pada superclass, namun memberikan cara subclass untuk merubah type nya.
Karakteristik  Ada abstraksi dari produk object menggunakan interface Setiap concrete implementation object produk tersebut, harus men=satisfy interface Ada sebuah function yang menjadi logic creational nya Function tersebut membutuhkan &amp;ldquo;data&amp;rdquo;, untuk menentukan object mana yang harus di create  package main // Coffee adalah abstraksi dari product type Coffee interface { Make() } // Arabica adalah konkrit product type Arabica struct {} func(a Arabica) Make() {} // Robusta adalah konkrit product type Robusta struct {} func(r Robusta) Make() {} // Data yang dibutuhkan untuk menentukan tipe produk const ( Arabica = iota Robusta ) // GetCoffee adalah fungsi creational dari produk Coffee func GetCoffee(t int) Coffee { switch t { case Arabica: return Arabica{} default: return Robusta{} } } func main() { coffee := GetCoffee(Arabica) coffee.</description>
    </item>
    
    <item>
      <title>Prototype Pattern</title>
      <link>http://example.org/posts/202108151527_prototype_pattern/</link>
      <pubDate>Mon, 16 Aug 2021 01:49:09 +0700</pubDate>
      
      <guid>http://example.org/posts/202108151527_prototype_pattern/</guid>
      <description>Prototype pattern menyediakan cara untuk meng-copy existing object tanpa membuat code harus dependen terhadap class mereka
Karakteristik  Tujuannya ingin membuat sebuat object baru dengan cara mengcopy object yang telah ada secara komplit (tidak bisa dilakukan secara direct, karena mungkin ada private field yang tidak bisa terlihat atau tidak dapat diakses dari sisi client) Mengcopy object tanpa harus terikat dengan logic bagaimana seharusnya object tersebut dicopy Adanya sebuah interface Prototype untuk mengabstraksi proses cloning.</description>
    </item>
    
    <item>
      <title>Singleton Pattern</title>
      <link>http://example.org/posts/202108151433_singleton_pattern/</link>
      <pubDate>Mon, 16 Aug 2021 01:49:09 +0700</pubDate>
      
      <guid>http://example.org/posts/202108151433_singleton_pattern/</guid>
      <description>Singleton menyediakan cara untuk membuat single instance dan menyediakan cara untuk mengakses/menggunakan instance tersebut sebagai global variable. Memastikan hanya terdapat satu instance dari produk tertentu selama aplikasi berjalan.
Karakterstik  Terdapat global variable untuk mendefine single instance. Dalam banyak implementasi, global variable tersebut memiliki default value dan tidak kosong, untuk selanjutnya bisa diganti melalui fungsi setter Adanya setter function untuk mengisi value dari instance tersebut Adanya getter function untuk memberikan cara agar package lain atau client mengakses instance tersebut Instance yang digukan untuk singleton harus bersifat private dan memastikan hanya dapat diubah/diisi sekali dalam compile time atau pun runtime Harus conccurent safe dan nil pointer safe (jika default value adalah nil)   Untuk memastikan bahwa instance hanya dapat sekali diubah/diisi, implementasi di Go dapat menggunakan sync.</description>
    </item>
    
  </channel>
</rss>
